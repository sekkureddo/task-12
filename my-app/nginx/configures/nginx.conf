# подключаю модуль для обработки изображений, который будет использоваться для поворота картинок в одном из location
load_module /usr/lib/nginx/modules/ngx_http_image_filter_module.so;
worker_processes auto;
pid /tmp/nginx.pid;
error_log /var/log/nginx/error.log;

events {
	worker_connections 1024;
}

http {
	include /etc/nginx/mime.types;
        log_format upstream_combined '$remote_addr - $remote_user [$time_local] '
                                 '"$request" $status $body_bytes_sent '
                                 '"$http_referer" "$http_user_agent" '
                                 'upstream_addr: $upstream_addr '
                                 'upstream_status: $upstream_status '
                                 'upstream_response_time: $upstream_response_time';

        upstream balance{
            # Балансировка между двумя серверами, которые будут запущены в контейнерах web_red и web_blue
             server web_red:80;
             server web_blue:80;
                }

   server {
    # С сертификатами все как всегда (это вариант для локалхоста, для aws настроить порт на 8443 ssl и расскоментить))
        # server_name nginxapacheapp.bounceme.net; 
        listen 8080;
        # ssl_certificate /etc/letsencrypt/live/nginxapacheapp.bounceme.net/fullchain.pem;
        # ssl_certificate_key /etc/letsencrypt/live/nginxapacheapp.bounceme.net/privkey.pem;
        root /var/www/site1.com;
        index index.html firstpage.html;
    
        # настройка для обработки запросов к API для работы скрипта, читает данные, которые будет скрипт писать которые не должны кэшироваться
        location /api/load {
        default_type text/plain;
        alias /var/www/site1.com/api/load;
        add_header Cache-Control "no-cache, no-store, must-revalidate";
    }

        location ~ \.mp3$ {
            add_header Content-Disposition 'attachment';
            add_header Content-Type 'application/octet-stream';
            try_files $uri =404;
        }

        location ~ /info\.php$ {
            # адрес апаче внутри compose сети
            proxy_pass http://apache:8080; 
            # подменяем запрос к апаче, т.к. апаче не знает про /info.php, у него только index.php, который мы так назвали для корректной дефольной обработки запросов, чтобы не нужно было прописывать пути вручную
            rewrite ^/info.php$ /index.php break; 
            # proxy_redirect http://apache:80 /;
            # без редиректа, потому что host $ host
            proxy_redirect off;
            proxy_set_header Host $host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /secondserver {
            return 301 https://www.numuki.com/ ;
}

         location ~ ^.*/image1/(.*\.jpg)$ {
             alias /var/www/site1.com/images/$1;
             expires 1m;
             add_header Cache-Control "public";
}

         location ~ ^.*/image2/(.*\.png)$ {
             alias /var/www/site1.com/images/$1;
             expires 1m;
             add_header Cache-Control "public";
             image_filter rotate 180;
}

        location = /redblue.html {
             proxy_pass http://balance/;
             proxy_set_header Host $host; 
             access_log /var/log/nginx/access.log upstream_combined;
             # добавила заголовки для отключения кэширования, чтобы при каждом запросе происходила балансировка между серверами, а не отдавался закэшированный результат
             add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
             expires off;
} 
    
   }

# блок для aws при переадресации с http на https, для локалхоста не нужен, так как сертификаты не используются 
# server {
#     listen 8080;
#     server_name nginxapacheapp.bounceme.net;

#     # Обязательно для работы Certbot
#     location /.well-known/acme-challenge/ {
#         root /var/www/certbot;
#     }

#     # Переадресация всех остальных запросов на HTTPS
#     location / {
#         return 301 https://$host$request_uri;
#     }
# }

}

